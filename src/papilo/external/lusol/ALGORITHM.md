# LUSOLアルゴリズム詳細解説 (数式・Fortranコード準拠)

## 序文：このドキュメントの目的

このドキュメントは、Fortranで記述された疎行列LU分解ライブラリ LUSOL の内部アルゴリズムを、ソースコードと数式を用いて詳細に解説することを目的としています。`lusol.f90` の実際のコードスニペットを引用し、その操作を数学的に定式化することで、LUSOLの複雑なロジックの正確な理解を支援します。

## サブルーチン命名規則の解読

LUSOLのサブルーチン名は、一見不可解に見えますが、体系的な命名規則に従っています。このパターンを理解することは、コードの構造を把握する上で非常に重要です。

**基本構造: `lu[V][F][A]`**

- **`lu`**: LUSOLパッケージのプレフィックス。
- **`[V]` (Version/Variant)**: 機能のバージョンやカテゴリを示す数字。
  - `1`: LU分解の初期化・実行 (`lu1fac`)。
  - `6`: 分解を用いた求解 (Solve) (`lu6sol`)。
  - `7`: 更新(Update)のための内部ユーティリティ (`lu7add`)。
  - `8`: 外部から呼び出し可能な更新操作 (`lu8rpc`)。
- **`[F]` (Function)**: サブルーチンの具体的な機能を示す3文字程度の略語。
  - `fac`: Factorization (分解)
  - `sol`: Solve (求解)
  - `mul`: Multiply (行列ベクトル積)
  - `rpc`: Replace Column (列置換)
  - `rpr`: Replace Row (行置換)
  - `adc`: Add Column (列追加)
  - `adr`: Add Row (行追加)
  - `dlc`: Delete Column (列削除)
  - `mod`: Rank-one Modification (ランク1更新)
  - `or*`: Order (入力データの整列)
  - `mar`: Markowitz (Markowitz法によるピボット探索)
  - `gau`: Gauss (ガウス消去)
- **`[A]` (Argument/Action)**: 操作対象や追加の動作を示す接尾辞。特に`lu6`系で顕著です。
  - `L`: 下三角行列 $L$ に対する操作。
  - `U`: 上三角行列 $U$ に対する操作。
  - `t`: 転置行列 ($L^T$ or $U^T$) に対する操作。

## データ構造: 疎行列のデュアル表現

LUSOLは、CSC（列リスト）とCSR（行リスト）に相当する2つのデータ構造を同時に保持します。これにより、ピボット探索に必要な行と列の非ゼロ要素数を高速に取得できます。

- **列リスト (Column List / CSC-like)**: 列 $j$ に含まれる非ゼロ要素 $A_{i_k, j}$ は、以下の配列要素に対応します。
  - 値: `a[k]`
  - 行インデックス: `indc[k] = i_k`
  - ここで、インデックス `k` は `locc[j]` から `locc[j] + lenc[j] - 1` の範囲を動きます。

- **行リスト (Row List / CSR-like)**: 行 $i$ に含まれる非ゼロ要素 $A_{i, j_k}$ は、以下の配列要素に対応します。
  - 列インデックス: `indr[k] = j_k`
  - ここで、インデックス `k` は `locr[i]` から `locr[i] + lenr[i] - 1` の範囲を動きます。

## パラメータと戻り値 (`lu1fac`)

LUSOLの動作は、主に整数配列`luparm(30)`と実数配列`parmlu(30)`によって制御されます。以下に主要なパラメータを抜粋します。

### 入力パラメータ

- **`luparm(6)`: ピボット戦略**
  - `0`: TPP (Threshold Partial Pivoting) - 各ステップで最もスパースな列を選び、その中で閾値条件を満たす最大の要素をピボットとします。
  - `1`: TRP (Threshold Rook Pivoting) - ピボット候補の行と列で安定性とスパース性を交互に探索します。TPPより安定性が高いですが、計算コストも増加します。
  - `2`: TCP (Threshold Complete Pivoting) - 残存する部分行列全体から、安定性とスパース性の基準を満たす最適なピボットを探します。最も安定的ですが、計算コストも最大です。
  - `3`: TSP (Threshold Symmetric Pivoting) - 対称行列向け。実質的にTRPと同じです。

- **`parmlu(1)`: `Ltol` - 安定性許容誤差**
  - ピボット選択時に許容されるLの要素の最大値（の逆数に関連）。$|L_{ij}| \le Ltol$ を保証しようとします。TPPでは10.0-100.0、TCP/TRPでは4.0-10.0が典型値です。

- **`parmlu(7)`: `dens1` / `parmlu(8)`: `dens2` - 密度閾値**
  - 分解が進むにつれて残存行列の密度が高くなった場合に、ピボット戦略を適応的に変更するための閾値です。

### 出力パラメータ

- **`inform`: 終了コード**
  - `0`: 成功。
  - `1`: Uが特異である可能性。
  - `4`: 重複した行列要素が入力された。
  - `7`: メモリ不足 (`lena`を`minlen`以上に増やす必要がある)。
  - `9`: TSP/TDPで対角ピボットが見つからなかった。

- **`luparm(11)`: `nsing` - 特異な対角要素の数**
- **`luparm(16)`: `nrank` - 計算されたUのランク**
- **`luparm(21)`: `lenL0` / `luparm(22)`: `lenU0` - 初期分解におけるLとUの非ゼロ要素数**
- **`parmlu(11)`: `Lmax` / `parmlu(12)`: `Umax` - LとUの最大要素**

## LU分解のメインプロセス (`lu1fac`)

`lu1fac`は、行列 $A$ を $PAQ=LU$ と分解するプロセスの高レベルドライバです。

### Step 1: 入力データの検証と内部形式への変換 (`lu1or*`)

ユーザーからの入力（座標形式）を内部の列リスト・行リスト形式に変換します。

### Step 2: 数値計算の核心 (`lu1fad`)

`lu1fad`は、分解のメインループを制御し、各ステップでピボットを選択し、ガウス消去を実行します。この際、**適応的ピボット戦略**を採用しています。

1.  **`Utri`フェーズ**: 分解の初期段階。行列が（置換後に）上三角に近い構造を持つことを期待し、コストの低いピボット探索（例：長さ1の列を探す）を行います。
2.  **`Ltri`フェーズ**: `Utri`が終了した後。次下三角に近い構造を探索します。
3.  **`spars1`フェーズ**: 残存行列の密度が`dens1`未満のスパースな段階。Markowitzカウントに基づき、計算コストとスパース性維持のバランスを取りながらピボットを探します。
4.  **`spars2`フェーズ**: 密度が`dens1`以上`dens2`未満。スパース性維持よりも数値的安定性をやや重視し、探索範囲を限定します。
5.  **`dense`フェーズ**: 密度が`dens2`以上。行列は密と見なされ、最も単純なピボット選択（最短列の先頭要素）に切り替わります。十分なメモリがあれば、この時点で密行列用のLU分解ルーチン(`lu1ful`)に処理を引き継ぎます。

この適応的戦略により、LUSOLは様々な構造の行列に対して効率的な分解を実現します。

## 線形方程式の求解と行列ベクトル積

### `lu6sol`: 線形方程式の求解

`lu6sol`は、LU因子を用いて線形方程式系 $Ax=b$ または $A^Tx=b$ を解きます。$A=L U$ (置換行列は省略) とすると、求解プロセスは2段階の三角行列ソルブに分割されます。

1.  **前進代入 (FTRAN):** $Ly = b$ を $y$ について解きます (`lu6L`)。
2.  **後退代入 (BTRAN):** $Ux = y$ を $x$ について解きます (`lu6U`)。

更新がイータ行列のリストとして保存されている場合、`lu6L`や`lu6U`は、まず元の$L_0, U_0$で解き、その後、保存されている全てのイータ行列の逆変換を順次適用することで、更新を反映した解を計算します。

### `lu6mul`: 行列ベクトル積

`lu6mul`は、求解ではなく、現在のLU因子を用いて行列ベクトル積を計算します。`mode`引数により、$L*v$, $L^T*v$, $U*w$, $U^T*v$, $A*w$, $A^T*v$ のいずれかの計算を実行できます。

## LU分解の更新

LUSOLは、一度計算したLU分解を、行列の変更に応じて効率的に更新する機能を提供します。これにより、例えばシンプレックス法の反復計算で、毎回LU分解を再計算するコストを回避できます。

### `lu8mod`: ランク1更新

多くの更新操作の基礎となるのが、行列 $A$ が $A + \beta v w^T$ というランク1行列で更新される場合の処理です。`lu8mod`は、この更新を以下の手順で行います。

1.  $L y = v$ を解き、$y$ を求めます。
2.  $U$の三角構造が、$y$と$w$によって崩されます。この崩れは、後方掃引 (`lu7bak`) と前方掃引 (`lu7for`) と呼ばれる一連のガウス消去操作によって修正され、再び三角構造が回復されます。

### `lu8rpc`: 列置換 (Replace Column)

基底行列 $B$ の1列 $a_p$ をベクトル $a_q$ で置き換える操作は、$B_{new} = B + (a_q - a_p) e_p^T$ と表現でき、これはランク1更新の一種です。しかし、この更新は構造が特殊であるため、より効率的な**Forrest-Tomlin法**が用いられます。この方法では、更新操作を明示的な行列計算ではなく、非常に疎な**イータ行列**の積として表現し、元のLU因子の末尾に情報を追記していくことで高速な更新を実現します。

### その他の更新操作

- **`lu8rpr` (行置換):** `lu8mod`を利用して、指定された行を新しい行ベクトルで置き換えます。
- **`lu8adc` (列追加):** `lu8rpc`のラッパーであり、「空の列を新しい列で置き換える」という操作として実現されます。
- **`lu8adr` (行追加):** 新しい行を下端に追加し、前方掃y (`lu7for`) を使ってUの三角構造を回復します。
- **`lu8dlc` (列削除):** Uから列を削除 (`lu7zap`) し、巡回置換 (`lu7cyc`) と前方掃引 (`lu7for`) を使って構造を修正します。

## イータ行列(eta-matrix)の物理的格納方法

`lu8rpc`による更新で生成されるイータ行列は、配列`a`と`indc`の空き領域にコンパクトな形式で格納されます。イータ行列は単位行列の1列を変更しただけなので、変更された列ベクトルとその位置情報のみを保存します。`lenc(j)`に負の値を設定することで、その列が通常のLU因子ではなくイータ行列であることを示します。

## メモリ管理: 圧縮 (`lu1rec`)

LUSOLは、単一の長大な配列 `a` をメモリプールとして使用します。分解や更新で配列が断片化し、連続した空き領域が不足すると、**`lu1rec` (Reclaim)** が呼び出されます。このルーチンは、有効なデータのみを配列の先頭に詰めることで、末尾に連続した空き領域を再生します。これは、フィルインやイータ行列を格納する領域が必要になった際に、`lu1fad`や`lu8rpc`から呼び出されます。