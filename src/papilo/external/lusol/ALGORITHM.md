# LUSOLアルゴリズム詳細解説 (数式・Fortranコード準拠)

## 序文：このドキュメントの目的

このドキュメントは、Fortranで記述された疎行列LU分解ライブラリ LUSOL の内部アルゴリズムを、ソースコードと数式を用いて詳細に解説することを目的としています。`lusol.f90` の実際のコードスニペットを引用し、その操作を数学的に定式化することで、LUSOLの複雑なロジックの正確な理解を支援します。

## サブルーチン命名規則の解読

LUSOLのサブルーチン名は、一見不可解に見えますが、体系的な命名規則に従っています。このパターンを理解することは、コードの構造を把握する上で非常に重要です。

**基本構造: `lu[V][F][A]`**

- **`lu`**: LUSOLパッケージのプレフィックス。
- **`[V]` (Version/Variant)**: 機能のバージョンやカテゴリを示す数字。
  - `1`: LU分解の初期化・実行 (`lu1fac`)。
  - `6`: 分解を用いた求解 (Solve) (`lu6sol`)。
  - `7`: 更新(Update)のための内部ユーティリティ (`lu7add`)。
  - `8`: 外部から呼び出し可能な更新操作 (`lu8rpc`)。
- **`[F]` (Function)**: サブルーチンの具体的な機能を示す3文字程度の略語。
  - `fac`: Factorization (分解)
  - `sol`: Solve (求解)
  - `rpc`: Replace Column (列置換)
  - `adc`: Add Column (列追加)
  - `or*`: Order (入力データの整列)
  - `mar`: Markowitz (Markowitz法によるピボット探索)
  - `gau`: Gauss (ガウス消去)
- **`[A]` (Argument/Action)**: 操作対象や追加の動作を示す接尾辞。特に`lu6`系で顕著です。
  - `L`: 下三角行列 $L$ に対する操作。
  - `U`: 上三角行列 $U$ に対する操作。
  - `t`: 転置行列 ($L^T$ or $U^T$) に対する操作。
  - `D`: 対角行列 $D$ に対する操作。

**具体例:**
- **`lu1fac`**: **LU**sol **V**ersion **1**, **Fac**torization. (LU分解を実行するメインルーチン)
- **`lu6sol`**: **LU**sol **V**ersion **6**, **Sol**ve. (線形方程式を解く)
- **`lu6L`**: `lu6sol`の内部ルーチンで、$L$ を使った前進代入 ($y = L^{-1}b$) を行う。
- **`lu6Lt`**: `lu6sol`の内部ルーチンで、$L^T$ を使った後退代入 ($y = L^{-T}b$) を行う。
- **`lu8rpc`**: **LU**sol **V**ersion **8**, **R**eplace **C**olumn. (列置換によるLU分解の更新)

## データ構造: 疎行列のデュアル表現

LUSOLは、CSC（列リスト）とCSR（行リスト）に相当する2つのデータ構造を同時に保持します。これにより、ピボット探索に必要な行と列の非ゼロ要素数を高速に取得できます。

- **列リスト (Column List / CSC-like)**: 列 $j$ に含まれる非ゼロ要素 $A_{i_k, j}$ は、以下の配列要素に対応します。
  - 値: `a[k]`
  - 行インデックス: `indc[k] = i_k`
  - ここで、インデックス `k` は `locc[j]` から `locc[j] + lenc[j] - 1` の範囲を動きます。

- **行リスト (Row List / CSR-like)**: 行 $i$ に含まれる非ゼロ要素 $A_{i, j_k}$ は、以下の配列要素に対応します。
  - 列インデックス: `indr[k] = j_k`
  - ここで、インデックス `k` は `locr[i]` から `locr[i] + lenr[i] - 1` の範囲を動きます。

## LU分解のメインプロセス (`lu1fac`)

`lu1fac`は、行列 $A$ を $PAQ=LU$ と分解するプロセスの高レベルドライバです。

### Step 1: 入力データの検証と内部形式への変換 (`lu1or*`)

ユーザーからの入力（座標形式）を内部の列リスト・行リスト形式に変換します。

**`lusol.f90`より引用:**
```fortran
! lu1fac内
call lu1or1( m, n, nelem, lena, small, ... )
call lu1or2( n, numnz, lena, a, indc, indr, lenc, locc )
call lu1or4( m, n, numnz, lena, indc, indr, lenc, lenr, locc, locr )
```
- **`lu1or1`**: $|A_{ij}| \le \text{small}$ となる要素を削除し、各行・列の非ゼロ要素数 `lenr[i]` と `lenc[j]` をカウントします。
- **`lu1or2`, `lu1or4`**: 上記のデータ構造定義に従い、列リストと行リストを構築します。

### Step 2: 数値計算の核心 (`lu1fad`)

`lu1fad`は、分解のメインループを制御し、各ステップ $k=1, \dots, \text{rank}$ でピボットを選択し、ガウス消去を実行します。

#### ピボット選択 (`lu1mar`)

各ステップで、残存する部分行列 $A^{(k-1)}$ の中から、次のピボット $A_{p,c}^{(k-1)}$ を選択します。選択基準は、**Markowitzカウント**の最小化と**閾値ピボット法**による安定性の確保です。

1.  **Markowitzカウント**: ピボット候補 $(i, j)$ のメリットを評価します。$r_i^{(k-1)}$ と $c_j^{(k-1)}$ を、それぞれ現在の部分行列における行 $i$ と列 $j$ の非ゼロ要素数とすると、Markowitzカウントは以下で定義されます。
    $$ M_{ij} = (r_i^{(k-1)} - 1) \times (c_j^{(k-1)} - 1) $$
    LUSOLは、この $M_{ij}$ が最小となる候補を探します。これはフィルインの発生を局所的に抑制するヒューリスティクスです。

2.  **閾値ピボット法 (Threshold Pivoting)**: 数値的安定性を確保するため、ピボット候補は以下の条件を満たす必要があります。
    $$ |A_{p,c}^{(k-1)}| \ge u \cdot \max_{i} |A_{i,c}^{(k-1)}| $$
    ここで $u \in (0, 1]$ は安定性パラメータ (`Ltol`) です。

#### ガウス消去とフィルイン (`lu1gau`)

ピボット $A_{p,c}^{(k-1)}$ が決まると、`lu1gau`が消去操作を実行します。これは数学的には、行列 $A^{(k-1)}$ に左からガウス変換行列 $G_k$ を掛けることに相当します。

1.  **LとUの要素計算**: ピボットが決定すると、新しいLの列とUの行が以下のように計算されます。
    - Uの行要素: $U_{kj} = A_{p,j}^{(k-1)}$ for $j=c, \dots, n$
    - Lの列要素: $L_{ic} = A_{i,c}^{(k-1)} / A_{p,c}^{(k-1)}$ for $i=p, \dots, m$

2.  **後続行列の更新**: 残りの部分行列（シューア補行列）は以下のように更新されます。
    $$ A_{i,j}^{(k)} = A_{i,j}^{(k-1)} - L_{ic} \cdot U_{kj} = A_{i,j}^{(k-1)} - \frac{A_{i,c}^{(k-1)} A_{p,j}^{(k-1)}}{A_{p,c}^{(k-1)}} $$
    この操作が `lu1gau` の中心的なループで実行されます。

**`lusol.f90`より引用 (`lu1gau`内):**
```fortran
! v = a_ij - al_i * au_j
! ここで al_i は L_ic、au_j は U_kj に相当する。
! a_ij は、列jの中から行iの要素を探して取得される。
```
- **フィルイン**: この更新で、元々 $A_{i,j}^{(k-1)}=0$ だった要素が $A_{i,j}^{(k)} \ne 0$ となる場合があります。これが**フィルイン**です。`lu1gau`は、フィルインが発生すると、列リスト (`a`, `indc`, `lenc`) と行リスト (`indr`, `lenr`) の両方のデータ構造を整合性を保ちながら更新します。この動的なデータ構造の変更が、実装上の最も複雑な部分です。

## LU分解の更新 (`lu8rpc`)

シンプレックス法では、基底行列 $B$ の1列 $a_p$ をベクトル $a_q$ で置き換える操作が頻繁に発生します。`lu8rpc`は、この更新を効率的に行います。

1.  **問題設定**: 新しい基底行列 $B_{new}$ は、元の基底 $B$ を用いて次のように表現できます。
    $$ B_{new} = B + (a_q - a_p) e_p^T $$
    ここで $a_p = B e_p$ であり、$e_p$ は $p$ 番目の単位ベクトルです。

2.  **更新の核心**: $B=LU$ の分解が既知であるため、$B_{new}$ の分解は、$L^{-1} B_{new}$ を考えることから始まります。
    $$ L^{-1} B_{new} = L^{-1}B + (L^{-1}a_q - L^{-1}a_p)e_p^T = U + (w - Ue_p)e_p^T $$
    ここで、ベクトル $w$ は線形方程式系 $Lw = a_q$ を解くことで得られます。この計算は、`lu8rpc`の冒頭で`lu6L`（前進代入）を呼び出すことで実行されます。

3.  **Hessenberg行列の分解**: 行列 $H = U + (w - Ue_p)e_p^T$ は、$U$ の $p$ 列目をベクトル $w$ で置き換えただけの行列です。この行列は、対角とその一つ下の要素までしか非ゼロ要素を持たない**上ヘッセンベルグ行列**となります。LU更新アルゴリズムの仕事は、この $H$ を効率的に再びLU分解することです。

4.  **Forrest-Tomlin法**: LUSOLが主に使用するForrest-Tomlin法は、数値的安定性のためのピボッティングを犠牲にして、疎性を維持することを優先します。$H$ を三角行列に戻すための変換を、明示的な行列として計算するのではなく、非常に疎な**イータ行列 (eta-matrix)** $\eta_k$ の積として表現します。更新後のLとUは、$L_{new} = L \cdot (\eta_1 \eta_2 \dots)$、$U_{new} = (\dots \eta_m^{-1}) \cdot H$ のような形式で暗黙的に保持されます。

**`lusol.f90`より引用 (`lu8rpc`内):**
```fortran
! 1. Lw = v を解く (vは置き換えたい新しい列 a_q)
call lu6L( mode1, m, v, w, ... )

! 2. Uのp列目をwで置き換えたHessenberg行列を分解する。
!    この処理は、eta-matrixを生成し、それを適用可能な形で
!    配列の末尾に格納していくことで実現される。
```

## イータ行列(eta-matrix)の物理的格納方法

LUSOLは、`lu8rpc`による更新で生成されるイータ行列を、明示的な行列としてではなく、非常にコンパクトな形式で格納します。この格納場所は、`lu1fac`でLとUの要素を格納した後の、**配列`a`と`indc`の空き領域**です。

イータ行列 $\eta$ は、単位行列の1つの列（例えば $p$ 列目）だけが非自明なベクトル $\begin{pmatrix} \dots, \eta_p, \dots \end{pmatrix}^T$ に置き換わった形をしています。このため、この行列を保存するには、以下の2つの情報だけが必要です。

1.  どの列が非自明か (the pivot column, $p$)
2.  その列の非ゼロ要素の値と、その行インデックス

LUSOLは、この情報を「イータファイル」と呼ばれる領域に、更新が行われるたびに追記していきます。このファイルは、物理的には配列`a`と`indc`の末尾に存在します。

### 格納フォーマット

`lu8rpc`が呼び出されるたびに、以下の情報が`a`と`indc`の末尾（`lenL`と`lenU`で示されるLとUの領域のさらに後ろ）に追記されます。

1.  **ヘッダ情報:**
    - 更新された列のインデックス `jrep` (どの列が置き換えられたか)。
    - このイータ行列の非ゼロ要素の数 `leneta`。

2.  **非ゼロ要素データ (長さ `leneta`):**
    - `a`配列: イータ行列の非自明な列の非ゼロ要素の値。
    - `indc`配列: 対応する行インデックス。

**`lusol.f90`の`lu8rpc`内の関連コード:**
```fortran
! lu8rpc内
! ... w (eta列) の計算後 ...

! 配列の最後にeta列を格納するスペースがあるかチェック
if (lfree < lenw) then
   ! ... 必要なら圧縮(lu1rec) ...
end if

! eta列をaとindcの末尾にコピー
do k = 1, lenw
   l           = lcol + k
   a(l)        = w(k)
   indc(l)     = iwx(k)
end do

! ヘッダ情報をlencとloccに格納
lenc(jrep) = -lenw  ! 負号は、これがeta列であることを示すマーカー
locc(jrep) = lcol + 1 ! eta列の開始位置
lcol       = lcol + lenw
```

- `lcol`は、列リスト（LとUの要素を含む）の現在の末尾を指すポインタです。イータ行列は、この`lcol`のさらに後ろに追加されます。
- `lenc(jrep)`に負の値を設定するのは、この列が通常のLU分解の一部ではなく、更新によって生成されたイータ行列であることを示すための巧妙なトリックです。

### 求解時の利用 (`lu6sol`)

`lu6sol`で線形方程式を解く際、`L`に対する前進代入（または`L^T`に対する後退代入）は、以下の2段階で行われます。

1.  **元のLによる求解:** まず、`lu1fac`で計算されたオリジナルの`L`因子を使って部分的な求解を行います。
2.  **イータ行列の適用:** 次に、`lenc`配列をスキャンし、負の値を持つエントリを探します。これが見つかると、対応するイータ行列を読み出し、その逆変換を解ベクトルに適用します。この処理を、蓄積された全てのイータ行列に対して、生成されたのと逆の順序で繰り返します。

この「分解は一度行い、更新はコンパクトなイータ行列のリストとして保持する」という戦略が、LUSOLの更新操作の効率性の根幹をなしています。