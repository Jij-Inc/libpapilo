# LUSOLアルゴリズム詳細解説 (数式・Fortranコード準拠)

## 序文：このドキュメントの目的

このドキュメントは、Fortranで記述された疎行列LU分解ライブラリ LUSOL の内部アルゴリズムを、ソースコードと数式を用いて詳細に解説することを目的としています。`lusol.f90` の実際のコードスニペットを引用し、その操作を数学的に定式化することで、LUSOLの複雑なロジックの正確な理解を支援します。

## サブルーチン命名規則の解読

LUSOLのサブルーチン名は、一見不可解に見えますが、体系的な命名規則に従っています。このパターンを理解することは、コードの構造を把握する上で非常に重要です。

**基本構造: `lu[V][F][A]`**

- **`lu`**: LUSOLパッケージのプレフィックス。
- **`[V]` (Version/Variant)**: 機能のバージョンやカテゴリを示す数字。
  - `1`: LU分解の初期化・実行 (`lu1fac`)。
  - `6`: 分解を用いた求解 (Solve) (`lu6sol`)。
  - `7`: 更新(Update)のための内部ユーティリティ (`lu7add`)。
  - `8`: 外部から呼び出し可能な更新操作 (`lu8rpc`)。
- **`[F]` (Function)**: サブルーチンの具体的な機能を示す3文字程度の略語。
  - `fac`: Factorization (分解)
  - `sol`: Solve (求解)
  - `mul`: Multiply (行列ベクトル積)
  - `rpc`: Replace Column (列置換)
  - `rpr`: Replace Row (行置換)
  - `adc`: Add Column (列追加)
  - `adr`: Add Row (行追加)
  - `dlc`: Delete Column (列削除)
  - `mod`: Rank-one Modification (ランク1更新)
  - `or*`: Order (入力データの整列)
  - `mar`: Markowitz (Markowitz法によるピボット探索)
  - `gau`: Gauss (ガウス消去)
- **`[A]` (Argument/Action)**: 操作対象や追加の動作を示す接尾辞。特に`lu6`系で顕著です。
  - `L`: 下三角行列 $L$ に対する操作。
  - `U`: 上三角行列 $U$ に対する操作。
  - `t`: 転置行列 ($L^T$ or $U^T$) に対する操作。

## データ構造: 疎行列のデュアル表現

LUSOLは、CSC（列リスト）とCSR（行リスト）に相当する2つのデータ構造を同時に保持します。これにより、ピボット探索に必要な行と列の非ゼロ要素数を高速に取得できます。

- **列リスト (Column List / CSC-like)**: 列 $j$ に含まれる非ゼロ要素 $A_{i_k, j}$ は、以下の配列要素に対応します。
  - 値: `a[k]`
  - 行インデックス: `indc[k] = i_k`
  - ここで、インデックス `k` は `locc[j]` から `locc[j] + lenc[j] - 1` の範囲を動きます。

- **行リスト (Row List / CSR-like)**: 行 $i$ に含まれる非ゼロ要素 $A_{i, j_k}$ は、以下の配列要素に対応します。
  - 列インデックス: `indr[k] = j_k`
  - ここで、インデックス `k` は `locr[i]` から `locr[i] + lenr[i] - 1` の範囲を動きます。

## パラメータと戻り値 (`lu1fac`)

LUSOLの動作は、主に整数配列`luparm(30)`と実数配列`parmlu(30)`によって制御されます。以下に主要なパラメータを抜粋します。

### 入力パラメータ

- **`luparm(6)`: ピボット戦略**
  - `0`: TPP (Threshold Partial Pivoting) - 各ステップで最もスパースな列を選び、その中で閾値条件を満たす最大の要素をピボットとします。
  - `1`: TRP (Threshold Rook Pivoting) - ピボット候補の行と列で安定性とスパース性を交互に探索します。TPPより安定性が高いですが、計算コストも増加します。
  - `2`: TCP (Threshold Complete Pivoting) - 残存する部分行列全体から、安定性とスパース性の基準を満たす最適なピボットを探します。最も安定的ですが、計算コストも最大です。
  - `3`: TSP (Threshold Symmetric Pivoting) - 対称行列向け。実質的にTRPと同じです。

- **`parmlu(1)`: `Ltol` - 安定性許容誤差**
  - ピボット選択時に許容されるLの要素の最大値（の逆数に関連）。$|L_{ij}| \le Ltol$ を保証しようとします。TPPでは10.0-100.0、TCP/TRPでは4.0-10.0が典型値です。

- **`parmlu(7)`: `dens1` / `parmlu(8)`: `dens2` - 密度閾値**
  - 分解が進むにつれて残存行列の密度が高くなった場合に、ピボット戦略を適応的に変更するための閾値です。

### 出力パラメータ

- **`inform`: 終了コード**
  - `0`: 成功。
  - `1`: Uが特異である可能性。
  - `4`: 重複した行列要素が入力された。
  - `7`: メモリ不足 (`lena`を`minlen`以上に増やす必要がある)。
  - `9`: TSP/TDPで対角ピボットが見つからなかった。

- **`luparm(11)`: `nsing` - 特異な対角要素の数**
- **`luparm(16)`: `nrank` - 計算されたUのランク**
- **`luparm(21)`: `lenL0` / `luparm(22)`: `lenU0` - 初期分解におけるLとUの非ゼロ要素数**
- **`parmlu(11)`: `Lmax` / `parmlu(12)`: `Umax` - LとUの最大要素**

## LU分解のメインプロセス (`lu1fac`)

`lu1fac`は、行列 $A$ を $PAQ=LU$ と分解するプロセスの高レベルドライバです。

### Step 1: 入力データの検証と内部形式への変換 (`lu1or*`)

ユーザーからの入力（座標形式）を内部の列リスト・行リスト形式に変換します。

### Step 2: 数値計算の核心 (`lu1fad`)

`lu1fad`は、分解のメインループを制御し、各ステップでピボットを選択し、ガウス消去を実行します。この際、**適応的ピボット戦略**を採用しています。

1.  **`Utri`フェーズ**: 分解の初期段階。行列が（置換後に）上三角に近い構造を持つことを期待し、コストの低いピボット探索（例：長さ1の列を探す）を行います。
2.  **`Ltri`フェーズ**: `Utri`が終了した後。次下三角に近い構造を探索します。
3.  **`spars1`フェーズ**: 残存行列の密度が`dens1`未満のスパースな段階。Markowitzカウントに基づき、計算コストとスパース性維持のバランスを取りながらピボットを探します。
4.  **`spars2`フェーズ**: 密度が`dens1`以上`dens2`未満。スパース性維持よりも数値的安定性をやや重視し、探索範囲を限定します。
5.  **`dense`フェーズ**: 密度が`dens2`以上。行列は密と見なされ、最も単純なピボット選択（最短列の先頭要素）に切り替わります。十分なメモリがあれば、この時点で密行列用のLU分解ルーチン(`lu1ful`)に処理を引き継ぎます。

この適応的戦略により、LUSOLは様々な構造の行列に対して効率的な分解を実現します。

## 線形方程式の求解と行列ベクトル積

### `lu6sol`: 線形方程式の求解

`lu6sol`は、LU因子を用いて線形方程式系 $Ax=b$ または $A^Tx=b$ を解きます。$A=L U$ (置換行列は省略) とすると、求解プロセスは2段階の三角行列ソルブに分割されます。

1.  **前進代入 (FTRAN):** $Ly = b$ を $y$ について解きます (`lu6L`)。
2.  **後退代入 (BTRAN):** $Ux = y$ を $x$ について解きます (`lu6U`)。

更新がイータ行列のリストとして保存されている場合、`lu6L`や`lu6U`は、まず元の$L_0, U_0$で解き、その後、保存されている全てのイータ行列の逆変換を順次適用することで、更新を反映した解を計算します。

### `lu6mul`: 行列ベクトル積

`lu6mul`は、求解ではなく、現在のLU因子を用いて行列ベクトル積を計算します。`mode`引数により、$L*v$, $L^T*v$, $U*w$, $U^T*v$, $A*w$, $A^T*v$ のいずれかの計算を実行できます。

## LU分解の更新

LUSOLは、一度計算したLU分解を、行列の変更に応じて効率的に更新する機能を提供します。これにより、例えばシンプレックス法の反復計算で、毎回LU分解を再計算するコストを回避できます。

### `lu8mod`: ランク1更新

多くの更新操作の基礎となるのが、行列 $A$ が $A + \beta v w^T$ というランク1行列で更新される場合の処理です。`lu8mod`は、この更新を以下の手順で行います。

1.  $L y = v$ を解き、$y$ を求めます。
2.  $U$の三角構造が、$y$と$w$によって崩されます。この崩れは、後方掃引 (`lu7bak`) と前方掃引 (`lu7for`) と呼ばれる一連のガウス消去操作によって修正され、再び三角構造が回復されます。

### `lu8rpc`: 列置換 (Replace Column)

基底行列 $B$ の1列 $a_p$ をベクトル $a_q$ で置き換える操作は、$B_{new} = B + (a_q - a_p) e_p^T$ と表現でき、これはランク1更新の一種です。しかし、この更新は構造が特殊であるため、より効率的な**Forrest-Tomlin法**が用いられます。この方法では、更新操作を明示的な行列計算ではなく、非常に疎な**イータ行列**の積として表現し、元のLU因子の末尾に情報を追記していくことで高速な更新を実現します。

### その他の更新操作

- **`lu8rpr` (行置換):** `lu8mod`を利用して、指定された行を新しい行ベクトルで置き換えます。
- **`lu8adc` (列追加):** `lu8rpc`のラッパーであり、「空の列を新しい列で置き換える」という操作として実現されます。
- **`lu8adr` (行追加):** 新しい行を下端に追加し、前方掃y (`lu7for`) を使ってUの三角構造を回復します。
- **`lu8dlc` (列削除):** Uから列を削除 (`lu7zap`) し、巡回置換 (`lu7cyc`) と前方掃引 (`lu7for`) を使って構造を修正します。

## LU分解の更新とイータ行列

シンプレックス法など、多くの最適化アルゴリズムでは、行列の一部を繰り返し変更しながら線形方程式を解く必要があります。毎回LU分解を再計算するのは非効率です。LUSOLは、**LU分解の更新**というテクニックを用いてこの問題に対処します。その中心的な概念が**イータ行列 (eta-matrix)** です。

### 更新の数学的背景 (`lu8rpc`)

シンプレックス法で最も一般的な更新は、基底行列 $B$ の $p$ 番目の列 $a_p$ を、新しいベクトル $a_q$ で置き換える操作です。新しい基底行列を $B_{new}$ とすると、この関係は次のように書けます。

$
B_{new} = B + (a_q - a_p) e_p^T
$

ここで $e_p$ は、$p$ 番目の要素のみが1で他が0の単位ベクトルです。$a_p = B e_p$ であることに注意してください。

我々は $B=LU$ という分解をすでに持っています。$B_{new}$ の逆行列を効率的に計算（または適用）するために、$L^{-1}$ を両辺に掛けます。

$
L^{-1} B_{new} = L^{-1}B + (L^{-1}a_q - L^{-1}a_p)e_p^T
$

$L^{-1}B = U$ であり、$a_p = U e_p$ です。また、$Lw = a_q$ となるベクトル $w$ を計算すると（これは`lu6L`による前進代入で効率的に求まります）、上式は以下のように変形できます。

$
L^{-1} B_{new} = U + (w - Ue_p)e_p^T
$

右辺の行列 $H \equiv U + (w - Ue_p)e_p^T$ は、上三角行列 $U$ の $p$ 番目の列をベクトル $w$ で置き換えただけの行列です。この行列 $H$ は、対角とそのすぐ下の要素までしか非ゼロ要素を持たない**上ヘッセンベルグ行列**となります。

したがって、LU更新の問題は、このほぼ上三角であるヘッセンベルグ行列 $H$ を、再び効率的に三角化する問題に帰着します。

### イータ行列による三角化 (Forrest-Tomlin法)

$H$ を上三角行列 $U_{new}$ に戻すには、下三角行列 $L_{update}$ を左から掛けて、$L_{update} H = U_{new}$ となるようにします。このとき、新しい分解は $B_{new} = (L L_{update}^{-1}) U_{new}$ となります。

Forrest-Tomlin法では、この $L_{update}$ を明示的に計算するのではなく、一連の非常に単純な行列、すなわち**イータ行列**の積として表現します。

イータ行列 $\eta_k$ とは、単位行列の1つの列（例えば $k$ 列目）だけが非自明なベクトル（イータベクトル）に置き換わった行列です。

$
\eta_k = \begin{pmatrix}
1 & & & & & \\
& \ddots & & & & \\
& & 1 & \eta_{k,k} & & \\
& & & \eta_{k+1,k} & 1 & \\
& & & \vdots & & \ddots & \\
& & & \eta_{m,k} & & & 1
\end{pmatrix}
$

このような行列の逆行列は、非対角要素の符号を変えるだけで簡単に計算できます。

$
\eta_k^{-1} = \begin{pmatrix}
1 & & & & & \\
& \ddots & & & & \\
& & 1 & -\eta_{k,k} & & \\
& & & -\eta_{k+1,k} & 1 & \\
& & & \vdots & & \ddots & \\
& & & -\eta_{m,k} & & & 1
\end{pmatrix}
$

ヘッセンベルグ行列 $H$ の下三角部分の非ゼロ要素は、$p$ 列目にしかありません。これらをガウス消去で除去していく操作は、一連のイータ行列 $\eta_p, \eta_{p+1}, \dots, \eta_{m-1}$ を左から掛けていくことに相当します。

$
(\eta_{m-1} \dots \eta_{p+1} \eta_p) H = U_{new}
$

結果として、更新後のLU分解は以下のようになります。

-   $L_{new} = L \cdot (\eta_p^{-1} \eta_{p+1}^{-1} \dots \eta_{m-1}^{-1})$
-   $U_{new} = (\eta_{m-1} \dots \eta_{p+1} \eta_p) H$

LUSOLは、これらのイータ行列を明示的に掛け合わせることはしません。代わりに、**イータベクトルとその位置のリスト**として、配列`a`の末尾にある「イータファイル」に追記していきます。

### イータ行列の物理的格納と利用

`lu8rpc`が呼び出されるたびに、上記のプロセスで導出されたイータベクトル（とその行インデックス）が、配列`a`と`indc`の末尾に追記されます。どの列の更新に対応するかを識別するために、`lenc(jrep)`に負の長さが格納されます。

線形方程式を解く際(`lu6sol`)、例えば前進代入 $Ly=b$ を実行するには、以下の操作を行います。

1.  **元の $L_0$ で解く:** まず、$y' = L_0^{-1} b$ を計算します。
2.  **イータ行列を適用する:** 次に、イータファイルのリストを生成順にたどり、各イータ行列 $\eta_i$ の逆変換を適用していきます: $y \leftarrow \eta_i^{-1} y$。

この「分解は一度だけ行い、更新は疎な変換のリストとして保持する」という戦略が、LUSOLの更新操作の効率性の根幹をなしています。


## メモリ管理: 圧縮 (`lu1rec`)

LUSOLは、単一の長大な配列 `a` をメモリプールとして使用します。分解や更新で配列が断片化し、連続した空き領域が不足すると、**`lu1rec` (Reclaim)** が呼び出されます。このルーチンは、有効なデータのみを配列の先頭に詰めることで、末尾に連続した空き領域を再生します。これは、フィルインやイータ行列を格納する領域が必要になった際に、`lu1fad`や`lu8rpc`から呼び出されます。